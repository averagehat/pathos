# Stubs for sh (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from StringIO import StringIO
from cStringIO import OutputType as cStringIO
from types import ModuleType
from typing import Any, Optional

__project_url__: str
IS_PY3: Any
MINOR_VER: Any
IS_PY26: Any
DEFAULT_ENCODING: Any
RUNNING_TESTS: Any
FORCE_USE_SELECT: Any
ioStringIO = StringIO
iocStringIO = cStringIO

def callable(ob: Any): ...

IS_OSX: Any
THIS_DIR: Any
SH_LOGGER_NAME = __name__
PUSHD_LOCK: Any

def get_num_args(fn: Any): ...
raw_input = input
unicode = str
basestring = str
long = int
HAS_POLL: Any
POLLER_EVENT_READ: int
POLLER_EVENT_WRITE: int
POLLER_EVENT_HUP: int
POLLER_EVENT_ERROR: int

class Poller:
    fd_lookup: Any = ...
    fo_lookup: Any = ...
    def __init__(self) -> None: ...
    def __nonzero__(self): ...
    def __len__(self): ...
    def register_read(self, f: Any) -> None: ...
    def register_write(self, f: Any) -> None: ...
    def register_error(self, f: Any) -> None: ...
    def unregister(self, f: Any) -> None: ...
    def poll(self, timeout: Any): ...

class Poller:
    rlist: Any = ...
    wlist: Any = ...
    xlist: Any = ...
    def __init__(self) -> None: ...
    def __nonzero__(self): ...
    def __len__(self): ...
    def register_read(self, f: Any) -> None: ...
    def register_write(self, f: Any) -> None: ...
    def register_error(self, f: Any) -> None: ...
    def unregister(self, f: Any) -> None: ...
    def poll(self, timeout: Any): ...

def encode_to_py3bytes_or_py2str(s: Any): ...

class ForkException(Exception):
    def __init__(self, orig_exc: Any) -> None: ...

class ErrorReturnCodeMeta(type):
    def __subclasscheck__(self, o: Any): ...

class ErrorReturnCode(Exception):
    __metaclass__: Any = ...
    truncate_cap: int = ...
    full_cmd: Any = ...
    stdout: Any = ...
    stderr: Any = ...
    def __init__(self, full_cmd: Any, stdout: Any, stderr: Any, truncate: bool = ...) -> None: ...

class SignalException(ErrorReturnCode): ...

class TimeoutException(Exception):
    exit_code: Any = ...
    def __init__(self, exit_code: Any) -> None: ...

SIGNALS_THAT_SHOULD_THROW_EXCEPTION: Any

class CommandNotFound(AttributeError): ...

rc_exc_regex: Any
rc_exc_cache: Any
SIGNAL_MAPPING: Any

def get_exc_from_name(name: Any): ...
def get_rc_exc(rc: Any): ...

class GlobResults(list):
    path: Any = ...
    def __init__(self, path: Any, results: Any) -> None: ...

def glob(path: Any, *args: Any, **kwargs: Any): ...
def which(program: Any, paths: Optional[Any] = ...): ...
def resolve_command_path(program: Any): ...
def resolve_command(name: Any, baked_args: Optional[Any] = ...): ...

class Logger:
    name: Any = ...
    log: Any = ...
    def __init__(self, name: Any, context: Optional[Any] = ...) -> None: ...
    context: Any = ...
    def set_context(self, context: Any) -> None: ...
    def get_child(self, name: Any, context: Any): ...
    def info(self, msg: Any, *args: Any) -> None: ...
    def debug(self, msg: Any, *args: Any) -> None: ...
    def error(self, msg: Any, *args: Any) -> None: ...
    def exception(self, msg: Any, *args: Any) -> None: ...

def default_logger_str(cmd: Any, call_args: Any, pid: Optional[Any] = ...): ...

class RunningCommand:
    ran: Any = ...
    call_args: Any = ...
    cmd: Any = ...
    process: Any = ...
    log: Any = ...
    def __init__(self, cmd: Any, call_args: Any, stdin: Any, stdout: Any, stderr: Any) -> None: ...
    def wait(self): ...
    def handle_command_exit_code(self, code: Any) -> None: ...
    @property
    def stdout(self): ...
    @property
    def stderr(self): ...
    @property
    def exit_code(self): ...
    def __len__(self): ...
    def __enter__(self) -> None: ...
    def __iter__(self): ...
    def next(self): ...
    __next__: Any = ...
    def __exit__(self, typ: Any, value: Any, traceback: Any) -> None: ...
    def __unicode__(self): ...
    def __eq__(self, other: Any): ...
    __hash__: Any = ...
    def __contains__(self, item: Any): ...
    def __getattr__(self, p: Any): ...
    def __long__(self): ...
    def __float__(self): ...
    def __int__(self): ...

def output_redirect_is_filename(out: Any): ...
def get_prepend_stack(): ...
def special_kwarg_validator(kwargs: Any, invalid_list: Any): ...
def get_fileno(ob: Any): ...
def ob_is_tty(ob: Any): ...
def ob_is_pipe(ob: Any): ...
def tty_in_validator(kwargs: Any): ...
def bufsize_validator(kwargs: Any): ...

class Command:
    thread_local: Any = ...
    __name__: Any = ...
    def __init__(self, path: Any, search_paths: Optional[Any] = ...) -> None: ...
    def __getattribute__(self, name: Any): ...
    def bake(self, *args: Any, **kwargs: Any): ...
    def __eq__(self, other: Any): ...
    __hash__: Any = ...
    def __unicode__(self): ...
    def __enter__(self) -> None: ...
    def __exit__(self, typ: Any, value: Any, traceback: Any) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any): ...

def compile_args(args: Any, kwargs: Any, sep: Any, prefix: Any): ...
def aggregate_keywords(keywords: Any, sep: Any, prefix: Any, raw: bool = ...): ...
def setwinsize(fd: Any, rows_cols: Any) -> None: ...
def construct_streamreader_callback(process: Any, handler: Any): ...
def get_exc_exit_code_would_raise(exit_code: Any, ok_codes: Any, sigpipe_ok: Any): ...
def handle_process_exit_code(exit_code: Any): ...
def no_interrupt(syscall: Any, *args: Any, **kwargs: Any): ...

class OProc:
    STDOUT: int = ...
    STDERR: int = ...
    command: Any = ...
    call_args: Any = ...
    ctty: Any = ...
    sid: Any = ...
    pgid: Any = ...
    pid: Any = ...
    timed_out: bool = ...
    started: Any = ...
    cmd: Any = ...
    exit_code: Any = ...
    stdin: Any = ...
    log: Any = ...
    def __init__(self, command: Any, parent_log: Any, cmd: Any, stdin: Any, stdout: Any, stderr: Any, call_args: Any, pipe: Any, process_assign_lock: Any) -> None: ...
    @property
    def output_thread_exc(self): ...
    @property
    def input_thread_exc(self): ...
    @property
    def bg_thread_exc(self): ...
    def change_in_bufsize(self, buf: Any) -> None: ...
    def change_out_bufsize(self, buf: Any) -> None: ...
    def change_err_bufsize(self, buf: Any) -> None: ...
    @property
    def stdout(self): ...
    @property
    def stderr(self): ...
    def get_pgid(self): ...
    def get_sid(self): ...
    def signal_group(self, sig: Any) -> None: ...
    def signal(self, sig: Any) -> None: ...
    def kill_group(self) -> None: ...
    def kill(self) -> None: ...
    def terminate(self) -> None: ...
    def is_alive(self): ...
    def wait(self): ...

def input_thread(log: Any, stdin: Any, is_alive: Any, quit: Any, close_before_term: Any) -> None: ...
def event_wait(ev: Any, timeout: Optional[Any] = ...): ...
def background_thread(timeout_fn: Any, timeout_event: Any, handle_exit_code: Any, is_alive: Any, quit: Any) -> None: ...
def output_thread(log: Any, stdout: Any, stderr: Any, timeout_event: Any, is_alive: Any, quit: Any, stop_output_event: Any) -> None: ...

class DoneReadingForever(Exception): ...
class NotYetReadyToRead(Exception): ...

def determine_how_to_read_input(input_obj: Any): ...
def get_queue_chunk_reader(stdin: Any): ...
def get_callable_chunk_reader(stdin: Any): ...
def get_iter_string_reader(stdin: Any): ...
def get_iter_chunk_reader(stdin: Any): ...
def get_file_chunk_reader(stdin: Any): ...
def bufsize_type_to_bufsize(bf_type: Any): ...

class StreamWriter:
    stream: Any = ...
    stdin: Any = ...
    log: Any = ...
    encoding: Any = ...
    tty_in: Any = ...
    stream_bufferer: Any = ...
    def __init__(self, log: Any, stream: Any, stdin: Any, bufsize_type: Any, encoding: Any, tty_in: Any) -> None: ...
    def fileno(self): ...
    def write(self): ...
    def close(self) -> None: ...

def determine_how_to_feed_output(handler: Any, encoding: Any, decode_errors: Any): ...
def get_fd_chunk_consumer(handler: Any): ...
def get_file_chunk_consumer(handler: Any): ...
def get_callback_chunk_consumer(handler: Any, encoding: Any, decode_errors: Any): ...
def get_cstringio_chunk_consumer(handler: Any): ...
def get_stringio_chunk_consumer(handler: Any, encoding: Any, decode_errors: Any): ...

class StreamReader:
    stream: Any = ...
    buffer: Any = ...
    save_data: Any = ...
    encoding: Any = ...
    decode_errors: Any = ...
    pipe_queue: Any = ...
    log: Any = ...
    stream_bufferer: Any = ...
    bufsize: Any = ...
    should_quit: bool = ...
    def __init__(self, log: Any, stream: Any, handler: Any, buffer: Any, bufsize_type: Any, encoding: Any, decode_errors: Any, pipe_queue: Optional[Any] = ..., save_data: bool = ...) -> None: ...
    def fileno(self): ...
    def close(self) -> None: ...
    def write_chunk(self, chunk: Any) -> None: ...
    def read(self): ...

class StreamBufferer:
    type: Any = ...
    buffer: Any = ...
    n_buffer_count: int = ...
    encoding: Any = ...
    decode_errors: Any = ...
    log: Any = ...
    def __init__(self, buffer_type: Any, encoding: Any = ..., decode_errors: str = ...) -> None: ...
    def change_buffering(self, new_type: Any) -> None: ...
    def process(self, chunk: Any): ...
    def flush(self): ...

def with_lock(lock: Any): ...
def pushd(path: Any) -> None: ...
def args(**kwargs: Any) -> None: ...

class Environment(dict):
    whitelist: Any = ...
    globs: Any = ...
    baked_args: Any = ...
    disable_whitelist: bool = ...
    def __init__(self, globs: Any, baked_args: Any = ...) -> None: ...
    def __getitem__(self, k: Any): ...
    def b_cd(self, path: Optional[Any] = ...) -> None: ...
    def b_which(self, program: Any, paths: Optional[Any] = ...): ...

class Contrib(ModuleType):
    @classmethod
    def __call__(cls, name: Any): ...

mod_name: Any
contrib: Any

def git(orig: Any): ...
def sudo(orig: Any): ...
def run_repl(env: Any) -> None: ...

class SelfWrapper(ModuleType):
    __path__: Any = ...
    def __init__(self, self_module: Any, baked_args: Any = ...) -> None: ...
    def __getattr__(self, name: Any): ...
    def __call__(self, **kwargs: Any): ...

def in_importlib(frame: Any): ...
def register_importer(): ...
def fetch_module_from_frame(name: Any, frame: Any): ...

class ModuleImporterFromVariables:
    restrict_to: Any = ...
    def __init__(self, restrict_to: Optional[Any] = ...) -> None: ...
    def find_module(self, mod_fullname: Any, path: Optional[Any] = ...): ...
    def load_module(self, mod_fullname: Any): ...

def run_tests(env: Any, locale: Any, args: Any, version: Any, force_select: Any, **extra_env: Any): ...
